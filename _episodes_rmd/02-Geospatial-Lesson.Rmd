---
title: "Ag Carpentry - Geospatial Data in different Ag file formats"
author: "Brittani"
date: "2019-10-19"
output: html_document
source: Rmd
---

```{r setup, include=FALSE}
library(knitr)
library(httr)
knitr::opts_chunk$set(echo = TRUE, fig.path='../figure/')
```

#### Motivating Questions:
- What are the common file types in agricultural data?
- What applications do I need to open these files?
- How can I make maps of my yield or application?

#### Objectives with Spatial Data:
- Determine whether data are stored in vector or raster format
- Identify the coordinate system for a dataset
- Talk about when data don't have a projection defined (missing .prj file)
- Determine UTM zone of a dataset
- Reproject the dataset into UTM
- Import geospatial files into your R environment
- Visualize geospatial data with R
- Create geospatial files from lat/long coordinates
- Create an ab-line

#### Keypoints:
- sf is prefereable for data analysis; it is easier to access the dataframe
- Projecting your data in utm is necessary for many of the geometric operations
you perform (e.g. making trial grids and splitting plots into subplot data)
- Different data formats that you are likely to encounter include gpkg, shp
(cpg, dbf, prj, sbn, sbx), geojson, and tif

### Setup

Below are the packages that we will use in this episode.

```{r, message=FALSE, warning=FALSE, include=FALSE}
library(sf)
library(fasterize)
library(gstat)
library(raster)
library(rjson)
library(httr)
library(rgdal)
library(rgeos)
library(maptools)
library(knitr)
library(tmap)
library(ggplot2)
library(gridExtra)
library(grid)
```

###Introducing Spatial Data with an Example Using Trial Design Data

####Read in the trial design

Use the function `read_sf()` to bring the dataset into your R environment.
Because we have already set the working directory for this file, we only need to
supply the file name. There are many functions for reading files into the
environment, but this function will create an object of class `sf`. This class
makes accessing spatial data much easier. Much like a data frame, you can access
variables within an `sf` object using the `$` operator, for example
`trial$DISTANCE`. For this and other reasons like the number of spatial
calculations available for `sf` objects, this class is perferred in most situations.

```{r readtrial}
trial <- read_sf("data/trialdesign.gpkg")
```

An `sf` object contains a geometry column. We can see the geometric points for
each polygon.
In geospatial terms, a polygon represents an area of land with distinct
boundaries represented by a series of points.

```{r geometry}
head(trial$geom)
```

####What is a projection?

Geospatial data has a coordinate reference system (CRS) that projects the map in
a specific location. A projection is a way of making the earth's curved surface fit into something you 
can represent on a flat computer screen. To understand why that matters, take a look
at the difference between [the Mercator projection](https://en.wikipedia.org/wiki/Mercator_projection#/media/File:Mercator_projection_Square.JPG) of the world and the 
[Boggs eumorphic projection](https://en.wikipedia.org/wiki/Boggs_eumorphic_projection#/media/File:Boggs_eumorphic_projection_SW.JPG)

In the Mercator projection, space that doesn't exist is created to make a "flat" map 
and Greenland and Antarctica disproportionately huge. In the Boggs projection, strategic 
slices are cut out of the ocean so that the sizes appear a bit closer to true, but Canada 
and Russia get pinched and Greenland gets bisected. There will always be some compromises 
made in a projection system that converts curved surfaces to flat ones for the same reason 
that it's difficult to make an orange peel lie flat. So the method you select will have an 
effect on your outcome.

####Check the coordinate reference system

Some coordinate reference systems, such as UTM zones, are
measured in meters from a reference point in the zone. Latitude and longitude
represent a different type of CRS, defined in terms of angles across a sphere.
Before combining files
and performing operations on a file, it is important to check the CRS. The
function for this is `st_crs().`

```{r checkCRS}
st_crs(trial)
```

The trial design is in lat/long. If we want to create measures of distance,
we need the trial design in UTM. First, we must determine the UTM zone of the
trial area. 

####Calculate the UTM zone from the longitude

The UTM system divides the surface of Earth between 80°S and 84°N latitude into
60 zones, each 6° of longitude in width. Zone 1 covers longitude 180° to 174° W;
zone numbering increases eastward to zone 60 that covers longitude 174 to 180
East. The following code takes a longitude point and determines its UTM zone.
`long2UTM()` is a function written to take the argument `long` and output the
result of the equation. `floor()` returns the largest integer that is not
greater than the input.  The `st_bbox()` function returns the bounding box of
the dataset, i.e. the four corners defining a rectangle that would contain all
of the polygons.  By taking the mean of the first and third items returned by
`st_bbox()`, we get the longitude of the point directly in the center of the box.

```{r calcutm}
long2UTM <- function(long){
  utm <- (floor((long + 180)/6) %% 60) + 1
  return(utm)
}

utmzone <- long2UTM(mean(st_bbox(trial)[c(1,3)]))
utmzone
```

We can see that `r mean(st_bbox(trial)[c(1,3)])` corresponds to UTM zone
`r utmzone`.

####Projection for UTM

**Dena's comprehension check here: The way to recognize the difference between 
UTM and WGS584 is whether some data or piece of code starts with 326 or 4326? From
reading what's here, it gives me the impression that that's more of
an external thing than something you'd see in the file/data? How do you know which one
you're looking at if you don't already know? I'd like to brainstorm on a way to make this
section a little easier to understand without doing damage to accuracy.**

Using the UTM zone we calculated above, we now need the full ESPG code to
transform the file to the new CRS. EPSG Geodetic Parameter Dataset is a public
registry of spatial reference systems, Earth ellipsoids, coordinate
transformations and related units of measurement. The ESPG is one way to assign
or transform the CRS in R. The ESPG for UTM always begins with "326" and the
last numbers are the number of the zone. The code below pastes together the full
ESPG code for any `utmzone` we calculate with `long2UTM`. `paste0()` pastes
together the two arguments `"326"` and `utmzone` as string. But when we transform
`trial` into UTM, we only need the ESPG number. So we convert that to numeric with
`as.numeric()`, giving us a final ESPG of `r paste0("326", utmzone)`.

```{r setcrs}
projutm <- as.numeric(paste0("326", utmzone))
projutm
```

All modern latitude and longitude coordinates use a standard called WGS84.  The ESPG 
for WGS84 is 4326. This is the projection your equipment reads, so any trial design 
files will need to be transformed back into WGS84 before you implement the trial. Also, 
all files from your machinery, such as yield, as-applied, and as-planted, will be 
reported in latitude and longitude.

**Dena: What differences do you see in the data itself to recognize whether you're looking at
WGS84 or UTM in order to know which code you need to use in the transformation?**

####Transform the projection of file

To transform the trial design file into UTM, use `st_transform` and the crs
object `projutm`.

```{r transform}
trialutm <- st_transform(trial, projutm)
```

**Exercise**
1. Bring the file called "hord_f98_asplanted_2017.shp" in your environment. Name
the object `planting`. This file contains the planting information for 2017.
2. Identify the CRS of the object. **Dena: So far I haven't seen anything that would help them understand how to do this, unless 326 or 4326 appear somewhere in code or data we haven't shown them in text yet? Or else I've missed something key that it may help to add in.**
3. Look at the geometry features. What kind of geometric features are in this dataset?
4. Transform the file to UTM or Lat/Long, depending on the current CRS.

**Solution**

```{r transformplanting}
planting <- read_sf("data/asplanted.gpkg")

st_crs(planting)

planting$geom

planting_latlong <- st_transform(planting, 4326)

st_crs(planting_latlong)
```

The cleaned planting file was in UTM initially. The zone is `r utmzone` which is to be 
expected as it is from the same field as the trial design file we worked with earlier. 
When we look at the geometry features, they are `r nrow(planting)` points defined in x 
and y coordinates. Using the ESPG for lat/long we covered earlier 4326, we create a new
file called `planting_latlong` with the CRS of WGS84.

```{r transformtrial}
trialutm <- st_transform(trial, projutm)
```

####Save the file 

Use `st_write()` to save an sf object. If you do not specify a directory, the working 
directory will be used. We include the object we are saving `trialutm` and the name 
we would like to give the saved file `"trial.gpkg"`. Additionally, we specify the
`layer_options` and `update` values to enable overwriting an existing file with the same name. 

You can save the file as a .gpkg or .shp file. The advantage of a .gpkg file is
that you only save one file rather than four files in a shapefile. Because
shapefiles contain multiple files, they can be corrupted if one piece is missing.
One example is a .prj file. In this case, the shapefile will have no CRS, and
you will need to determine the CRS of the object. You will often need to transform a 
file from UTM to lat/long and save the new file during trial design, so this is an important step.

```{r save}
st_write(trialutm, "trial_utm.gpkg", layer_options = 'OVERWRITE=YES', update = TRUE)
```

The new .gpkg file will be visible in your working directory. One common problem
with these files is that when you try to open a .gpkg file for the first time in
R, it might not work if you haven't opened it in QGIS before.
**Dena: Any idea why this is? During Thursday's meeting, we weren't sure if we were going to get into
QGIS. If this is something that is critical, we should make sure to get QGIS available.**

####Visualize the trial map

We often want to visualize the contents of geospatial files. When we design a trial, 
we need to see the resulting applications. With yield data, we look for spatial patterns 
in the field, where is the yield higher or more varied. Before making a map, we need to
know what variables are in the trial dataset.
Use `names()` to view the different variables in `trialutm`. Say we want to make a
map of the nitrogen rates. We need to identify the variable name for the target
nitrogen.


```{r trialsumm}
names(trialutm)
```


In `trialutm` there are 11 variables, but the variables we might want to map are
`NRATE` and `SEEDRATE`. The following map is created with functions from a package 
called `tmap`. We are using `tm_polygon()`
fill the polygons with a color based on the variable `NRATE` inside the object
`trialutm `. For a different kind of geospatial data such as points, we need to use
`tm_dots()` or `tm_squares()`. `tmap` provides many options for displaying data, 
including text markers on the map. Text labels might be good for making a map of 
several land parcels with their names as the label. We use other arguments in the
code below to choose the position of the map
legend, title of the variable, size of text, and width of legend.


```{r map}
tm_shape(trialutm) + tm_polygons('NRATE', title = "Nitrogen Rate") +
  tm_layout(legend.outside = TRUE, frame = FALSE) +
  tm_legend(text.size = 1,
            title.size = 1,
            width = 100,
            bg.color = "white")
```


####Creating Spatial Objects

You may also have the coordinates of a spatial object but not a spatial file.
One example is a boundary file or AB-line for your field. We will use the
AB-line and boundary files later when designing the trials. But for this
example, they are good for displaying how to create a spatial object from
coordinates. 

####AB-line File (reading it in or creating it)

Some of you may have a shapefile of your ab-line, but most of you will have the
two endpoints. This is all you need to make a geospatial object for your ab_line 
in R. First, we define the latitude and longitude of the two points. We will call
these point A and point B.

```{r points }
LongA <- -82.97452
LatA <- 40.73862

LongB <- -82.97452
LatB <- 40.74480
```

`st_linestring()` creates an object of class sf from a matrix.
`rbind(c(LongA, LatA), c(LongB, LatB))` creates a matrix with two rows, one for point A and
one for point B. This object is then piped into the function `st_linestring()` to create 
the `sf` object. Finally, using `st_sf()` and  `st_sfc()` we create a simple feature geometry 
column from the set of geometries in `ab_string`. 

```{r abline }
ab_string <- rbind(c(LongA, LatA), c(LongB, LatB)) %>% st_linestring() 
ab_line <-st_sf(id = 'ab_line', st_sfc(ab_string))
```

Now we must assign the CRS of the line. We know that the coordinates were taken
from an object in WGS84, **Dena - How do we know that?** so we can assign the same 
CRS with `st_crs` and typing
out the correct `crs`. Another way we can do this is by using `crs()`. This
second method is preferred to avoid mistakes when remembering the UTM zone of
multiple files. **Dena: If the second method is preferred, then let's not introduce
the first method, so that the instructions they see lead them to do the right thing.**

```{r ab_lineproj}
st_crs(ab_line) <- st_crs(trial)
st_crs(ab_line)
st_write(ab_line,"abline.gpkg", layer_options = 'OVERWRITE=YES', update = TRUE)
```

Plot the resulting AB-line with the generic plotting function for `sf` objects.

```{r plotabline }
plot(ab_line)
```

####Reading in the Boundary File

We will read in the boundary file and plot the boundary file with the abline to see 
how the farmer drives across the field. 

```{r boundary}
boundary <- read_sf("data/boundary.gpkg")
st_crs(boundary)
```

After plotting `boundary`, we plot `ab_line` with `add = TRUE` which adds the new 
plot over the existing plot of the field boundary. We see that the farmer drives 
across the longest part of the field, beginning on the right-hand side. 

```{r plotboth }
plot(boundary$geom)
plot(ab_line, add = TRUE)
```
