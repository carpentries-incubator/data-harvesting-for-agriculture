I"Eó<h2 id="data-cleaning-and-aggregation-in-the-difm-project">Data cleaning and aggregation in the DIFM project</h2>

<p>We saw in the last episode that we can make graphs of our trial data, but right now they are all points that cannot easily be combined. For example, we do not know what the yield was at a specific nitrogen or seeding point on the field. But that is important if we are going to talk about the results of the trial. We need to know what the yield was when a certain seeding and nitrogen rate combination was applied. To do this, we first clean the trial points and then create a grid over the field. Inside that grid, we aggregate the points from each data type and report the median of the points that fall into each polygon of the grid. These will form a new dataset where we can directly relate a yield value to a given seed and nitrogen treatment. In the context of trials, the polygons of the grid are typically called the <em>units of observation.</em></p>

<h2 id="data-cleaning-details">Data Cleaning Details</h2>

<p>After harvesting, we collect all the data needed for analysis, and in advance of running analysis, we clean and organize the data in order to remove machinery error and such. In particular, we need to clean yield data, as-planted data, as-applied data, and sometimes EC data. For public data, we simply import them into our aggregated data set without cleaning, as they have already been cleaned before being released to the public.</p>

<p>Here are the main concerns for yield, as-planted, and as-applied data:</p>

<ul>
  <li>Observations where the harvester/planter/applicator is moving too slow or too fast</li>
  <li>Observations on the edges of the plot</li>
  <li>Observations that are below or above three standard deviations from the mean</li>
</ul>

<h2 id="step-1-importing-and-transforming-our-shapefile-datasets">Step 1: Importing and transforming our shapefile datasets</h2>

<!-- Let's apply this data-cleaning thinking to measurements of yields.  First, we will aggregate our yields into a grid overlayed on top of our boundary shapefile and look for measurements on this grid that seem too low or to high, and flag these as "outliers" of our dataset in our data-cleaning process. -->

<p>The first step is to read in our boundary and abline shape files and transform them to UTM for later use.  Let‚Äôs do this step-by-step, starting with reading in the boundary shapefile and projecting it:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">boundary</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read_sf</span><span class="p">(</span><span class="s2">"data/boundary.gpkg"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>What is the current coordinate reference system of this object?</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">st_crs</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Coordinate Reference System:
  EPSG: 4326 
  proj4string: "+proj=longlat +datum=WGS84 +no_defs"
</code></pre></div></div>
<p>Let‚Äôs transform it to the UTM projection &amp; check out its new coordinate reference system:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">boundary_utm</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">st_transform_utm</span><span class="p">(</span><span class="n">boundary</span><span class="p">)</span><span class="w">
</span><span class="n">st_crs</span><span class="p">(</span><span class="n">boundary_utm</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Coordinate Reference System:
  EPSG: 32617 
  proj4string: "+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"
</code></pre></div></div>
<p>Now we can see that the <code class="highlighter-rouge">+proj=longlat</code> has changed to <code class="highlighter-rouge">+proj=utm</code> and gives us that we are in UTM zone #17.</p>

<p>In the last episode, we also imported our trial design, which we will do again here:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">trial</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read_sf</span><span class="p">(</span><span class="s2">"data/trial.gpkg"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Let‚Äôs look at the coordinate reference system here as well:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">st_crs</span><span class="p">(</span><span class="n">trial</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Coordinate Reference System:
  EPSG: 32617 
  proj4string: "+proj=utm +zone=17 +datum=WGS84 +units=m +no_defs"
</code></pre></div></div>

<p>Our file is already in the UTM projection, but if we have one that is not we can convert this as well with <code class="highlighter-rouge">trial_utm &lt;- st_transform_utm(trial)</code>.  For the sake of naming, we‚Äôll rename it as <code class="highlighter-rouge">trial_utm</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">trial_utm</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">trial</span><span class="w">
</span></code></pre></div></div>

<blockquote class="challenge">
  <h2 id="exercise-transform-the-yield-data">Exercise: Transform the yield data</h2>
  <p>Read in the yield shape file, look at its current CRS and transform it into the UTM projection.  Call this new, transformed variable <code class="highlighter-rouge">yield_utm</code>.</p>

  <blockquote class="solution">
    <h2 id="solution">Solution</h2>
    <p>First, load the data:</p>

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yield</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read_sf</span><span class="p">(</span><span class="s2">"data/yield.gpkg"</span><span class="p">)</span><span class="w">
</span></code></pre></div>    </div>
    <p>Then take a look at the coordinate system:</p>

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">st_crs</span><span class="p">(</span><span class="n">yield</span><span class="p">)</span><span class="w">
</span></code></pre></div>    </div>

    <div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Coordinate Reference System:
  EPSG: 4326 
  proj4string: "+proj=longlat +datum=WGS84 +no_defs"
</code></pre></div>    </div>
    <p>And finally transform into UTM:</p>

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yield_utm</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">st_transform_utm</span><span class="p">(</span><span class="n">yield</span><span class="p">)</span><span class="w">
</span></code></pre></div>    </div>

  </blockquote>
</blockquote>

<p>Finally, let‚Äôs transform our abline file.  We read in the file:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st_read</span><span class="p">(</span><span class="s2">"data/abline.gpkg"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Reading layer `abline' from data source `/Users/jillnaiman/trial-lesson_ag/_episodes_rmd/data/abline.gpkg' using driver `GPKG'
Simple feature collection with 1 feature and 1 field
geometry type:  LINESTRING
dimension:      XY
bbox:           xmin: -82.87334 ymin: 40.84301 xmax: -82.87322 ymax: 40.84611
epsg (SRID):    4326
proj4string:    +proj=longlat +datum=WGS84 +no_defs
</code></pre></div></div>
<p>Check out its current coordinate reference system:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">st_crs</span><span class="p">(</span><span class="n">abline</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Coordinate Reference System:
  EPSG: 4326 
  proj4string: "+proj=longlat +datum=WGS84 +no_defs"
</code></pre></div></div>
<p>And transform it to UTM:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abline_utm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st_transform_utm</span><span class="p">(</span><span class="n">abline</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<h2 id="step-2-clean-the-yield-data">Step 2: Clean the yield data</h2>

<p>Now that we have our shapefiles in the same UTM coordinate system reference frame, we will apply some of our knowledge of data cleaning to take out weird observations. We know we have ‚Äúweird‚Äù measurements by looking at a histogram of our yield data:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hist</span><span class="p">(</span><span class="n">yield_utm</span><span class="o">$</span><span class="n">Yld_Vol_Dr</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../fig/rmd-unnamed-chunk-10-1.png" title="plot of chunk unnamed-chunk-10" alt="plot of chunk unnamed-chunk-10" width="612" style="display: block; margin: auto;" /></p>

<p>The fact that this histogram has a large tail where we see a few measurements far beyond the majority around 250 means we know we have some weird data points.</p>

<p>We will take out these weird observations in two steps:</p>
<ol>
  <li>First, we will take out observations we <em>know</em> will be weird because they are taken from the edges of our plot.</li>
  <li>Second, we will take out observations that are too far away from where the majority of the other yield measurements lie.</li>
</ol>

<p>Let‚Äôs go through these one by one.</p>

<h3 id="data-cleaning-1-taking-out-border-observations">Data cleaning #1: Taking out border observations</h3>

<p>We need to remove the yield observations that are on the border of the plots,
and also at the end of the plots.  The reason for this is that along the edge
of a plot, the harvester is likely to measure a mixture of two plots,
and therefore the data won‚Äôt be accurate for either plot.  Additionally,
plants growing at the edge of the field are likely to suffer from wind and other
effects, lowering their yields.  We will use the <code class="highlighter-rouge">trial_utm</code> shapefile to help us clean.</p>

<p>We add a 15 <font color="magenta">meter??</font> border.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yield_clean_border</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">clean_buffer</span><span class="p">(</span><span class="n">trial_utm</span><span class="p">,</span><span class="w"> </span><span class="m">15</span><span class="p">,</span><span class="w"> </span><span class="n">yield_utm</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Let‚Äôs use our side-by-side plotting we did in the previous episode to compare our original and border-yield cleaned yield maps:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yield_plot_orig</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">map_points</span><span class="p">(</span><span class="n">yield_utm</span><span class="p">,</span><span class="w"> </span><span class="s2">"Yld_Vol_Dr"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Yield, Orig"</span><span class="p">)</span><span class="w">
</span><span class="n">yield_plot_border_cleaned</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">map_points</span><span class="p">(</span><span class="n">yield_clean_border</span><span class="p">,</span><span class="w"> </span><span class="s2">"Yld_Vol_Dr"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Yield, No Borders"</span><span class="p">)</span><span class="w">
</span><span class="n">yield_plot_comp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tmap_arrange</span><span class="p">(</span><span class="n">yield_plot_orig</span><span class="p">,</span><span class="w"> </span><span class="n">yield_plot_border_cleaned</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">yield_plot_comp</span><span class="w">
</span></code></pre></div></div>

<p><img src="../fig/rmd-unnamed-chunk-12-1.png" title="plot of chunk unnamed-chunk-12" alt="plot of chunk unnamed-chunk-12" width="612" style="display: block; margin: auto;" /></p>

<p>Here again, we also check the distribution of cleaned yield by making a histogram.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hist</span><span class="p">(</span><span class="n">yield_clean_border</span><span class="o">$</span><span class="n">Yld_Vol_Dr</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../fig/rmd-unnamed-chunk-13-1.png" title="plot of chunk unnamed-chunk-13" alt="plot of chunk unnamed-chunk-13" width="612" style="display: block; margin: auto;" /></p>

<p>Looking at both this histogram and the several very red dots in our de-bordered yield map, we see that there are still a lot of very high observations. So we need to proceed to step two, which will clean our observations based on how far they are from the mean of the observations.</p>

<h3 id="data-cleaning-2-taking-out-outliers-far-from-the-mean">Data cleaning #2: Taking out outliers far from the mean</h3>

<p>Even if we don‚Äôt know the source of error, we can tell that some observations
are incorrect just because they are far too small or too large.  How can we
remove these in an objective, automatic way?  For yield and our other variables,
we will calculate the <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a>
to get an idea of how much the observations tend to be different from the mean.
Then, we will remove observations that are three standard deviations higher or
lower than the mean.  If the data followed a normal distribution (i.e a bell
curve), this would eliminate about one in 1000 data points.  In a real dataset,
we can be fairly certain that those points are errors.  Our cutoff of three
standard deviations is arbitrary, which is why we have looked at histograms of
the data to help confirm that our cutoff makes sense.</p>

<p>In the next few steps, we use <code class="highlighter-rouge">sd</code> and <code class="highlighter-rouge">mean</code> to calculate the standard
deviation and mean of the yield distribution, respectively. Then we remove the
yield observations that are greater than mean + 3*sd or less than mean - 3*sd.  We use
the <code class="highlighter-rouge">clean_sd</code> from our <code class="highlighter-rouge">functions.R</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yield_clean</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">clean_sd</span><span class="p">(</span><span class="n">yield_clean_border</span><span class="p">,</span><span class="w"> </span><span class="n">yield_clean_border</span><span class="o">$</span><span class="n">Yld_Vol_Dr</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Here again, we check the distribution of cleaned yield after taking out the
yield observations that are outside the range of three standard deviations from
the mean.</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hist</span><span class="p">(</span><span class="n">yield_clean</span><span class="o">$</span><span class="n">Yld_Vol_Dr</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../fig/rmd-view the distribution of cleaned yield data-1.png" title="plot of chunk view the distribution of cleaned yield data" alt="plot of chunk view the distribution of cleaned yield data" width="612" style="display: block; margin: auto;" /></p>

<!-- 
This looks a lot more sensible!  We can double check by comparing all the stages of our data cleaning on a map:

~~~
yield_plot_orig <- map_points(yield_utm, "Yld_Vol_Dr", "Yield, Orig")
yield_plot_border_cleaned <- map_points(yield_clean_border, "Yld_Vol_Dr", "Yield, No Borders")
yield_plot_clean <- map_points(yield_clean, "Yld_Vol_Dr", "Yield, Cleaned")
yield_plot_comp_final <- tmap_arrange(yield_plot_orig, yield_plot_border_cleaned, yield_plot_clean, ncol = 3, nrow = 1)
yield_plot_comp_final
~~~
{: .language-r}



~~~
Some legend labels were too wide. These labels have been resized to 0.62, 0.54, 0.54. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.
~~~
{: .output}



~~~
Some legend labels were too wide. These labels have been resized to 0.62, 0.54. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.
~~~
{: .output}

<img src="../fig/rmd-unnamed-chunk-14-1.png" title="plot of chunk unnamed-chunk-14" alt="plot of chunk unnamed-chunk-14" width="612" style="display: block; margin: auto;" />
-->

<p>This looks a lot more sensible!  We can double check by looking at our final, cleaned yield map:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">yield_plot_clean</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">map_points</span><span class="p">(</span><span class="n">yield_clean</span><span class="p">,</span><span class="w"> </span><span class="s2">"Yld_Vol_Dr"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Yield, Cleaned"</span><span class="p">)</span><span class="w">
</span><span class="n">yield_plot_clean</span><span class="w">
</span></code></pre></div></div>

<p><img src="../fig/rmd-unnamed-chunk-15-1.png" title="plot of chunk unnamed-chunk-15" alt="plot of chunk unnamed-chunk-15" width="612" style="display: block; margin: auto;" /></p>

<blockquote class="callout">
  <h2 id="discussion">Discussion</h2>
  <p>What do you think could have caused these outliers (extreme values)?  If you
were working with yield data from your own fields, what other sources of error
might you want to look for?</p>

</blockquote>

<blockquote class="challenge">
  <h2 id="exercise-cleaning-nitrogen-from-asapplied">Exercise: Cleaning Nitrogen from asapplied</h2>

  <p>Import the <code class="highlighter-rouge">asapplied.gpkg</code> shapefile for and clean the nitrogen application data.</p>
  <ol>
    <li>Remove observations from the
buffer zone, <font color="magenta">JPN: probably we need a different buffer length for this since I'm getting plots that have taken too much out in the boundary-removal process</font></li>
    <li>as well as observations more then three standard deviations from
the mean.</li>
  </ol>

  <blockquote class="solution">
    <h2 id="solution-1">Solution</h2>
    <p>Load the data</p>

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nitrogen</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">read_sf</span><span class="p">(</span><span class="s2">"data/asapplied.gpkg"</span><span class="p">)</span><span class="w">
</span></code></pre></div>    </div>
    <p>Check CRS</p>

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">st_crs</span><span class="p">(</span><span class="n">nitrogen</span><span class="p">)</span><span class="w">
</span></code></pre></div>    </div>

    <div class="output highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Coordinate Reference System:
  EPSG: 4326 
  proj4string: "+proj=longlat +datum=WGS84 +no_defs"
</code></pre></div>    </div>
    <p>Since it‚Äôs in Lat/Long we have to transform it:</p>

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nitrogen_utm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st_transform_utm</span><span class="p">(</span><span class="n">nitrogen</span><span class="p">)</span><span class="w">
</span></code></pre></div>    </div>
    <p>Clean border:</p>

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nitrogen_clean_border</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">clean_buffer</span><span class="p">(</span><span class="n">trial_utm</span><span class="p">,</span><span class="w"> </span><span class="m">15</span><span class="p">,</span><span class="w"> </span><span class="n">nitrogen_utm</span><span class="p">)</span><span class="w">
</span></code></pre></div>    </div>
    <p>Check out our progress with a plot:</p>

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nitrogen_plot_orig</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">map_points</span><span class="p">(</span><span class="n">nitrogen_utm</span><span class="p">,</span><span class="w"> </span><span class="s2">"Rate_Appli"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Nitrogen, Orig"</span><span class="p">)</span><span class="w">
</span><span class="n">nitrogen_plot_border_cleaned</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">map_points</span><span class="p">(</span><span class="n">nitrogen_clean_border</span><span class="p">,</span><span class="w"> </span><span class="s2">"Rate_Appli"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Nitrogen, No Borders"</span><span class="p">)</span><span class="w">
</span><span class="n">nitrogen_plot_comp</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">tmap_arrange</span><span class="p">(</span><span class="n">nitrogen_plot_orig</span><span class="p">,</span><span class="w"> </span><span class="n">nitrogen_plot_border_cleaned</span><span class="p">,</span><span class="w"> </span><span class="n">ncol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">nrow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">)</span><span class="w">
</span><span class="n">nitrogen_plot_comp</span><span class="w">
</span></code></pre></div>    </div>

    <p><img src="../fig/rmd-unnamed-chunk-20-1.png" title="plot of chunk unnamed-chunk-20" alt="plot of chunk unnamed-chunk-20" width="612" style="display: block; margin: auto;" />
Clean by standard deviation:</p>

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nitrogen_clean</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">clean_sd</span><span class="p">(</span><span class="n">nitrogen_clean_border</span><span class="p">,</span><span class="w"> </span><span class="n">nitrogen_clean_border</span><span class="o">$</span><span class="n">Rate_Appli</span><span class="p">)</span><span class="w">
</span></code></pre></div>    </div>
    <p>Plot our final result on a map:</p>

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nitrogen_plot_clean</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">map_points</span><span class="p">(</span><span class="n">nitrogen_clean</span><span class="p">,</span><span class="w"> </span><span class="s2">"Rate_Appli"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Nitrogen, Cleaned"</span><span class="p">)</span><span class="w">
</span><span class="n">nitrogen_plot_clean</span><span class="w">
</span></code></pre></div>    </div>

    <p><img src="../fig/rmd-unnamed-chunk-22-1.png" title="plot of chunk unnamed-chunk-22" alt="plot of chunk unnamed-chunk-22" width="612" style="display: block; margin: auto;" />
And as a histogram:</p>

    <div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hist</span><span class="p">(</span><span class="n">nitrogen_clean</span><span class="o">$</span><span class="n">Rate_Appli</span><span class="p">)</span><span class="w">
</span></code></pre></div>    </div>

    <p><img src="../fig/rmd-unnamed-chunk-23-1.png" title="plot of chunk unnamed-chunk-23" alt="plot of chunk unnamed-chunk-23" width="612" style="display: block; margin: auto;" /></p>

  </blockquote>
</blockquote>

<h1 id="designing-trials-generating-grids-and-aggregating">Designing Trials: Generating Grids and Aggregating</h1>

<p>Now that we have cleaned data, we will go through the steps to aggregate this data on subplots of our shapefile of our farm.  This happens in a few steps.</p>

<h2 id="step-1-creating-the-subplots">Step 1: Creating the subplots</h2>

<p>After we read in the trial design file, we use a function to generate the
subplots for this trial. Because the code for generating the subplots is
somewhat complex, we have included it as the <code class="highlighter-rouge">make_grids</code> function in <code class="highlighter-rouge">functions.R</code>.</p>

<p>To start, we only want to look at data in the <code class="highlighter-rouge">Trial</code> portion of our plot, so we take a subset of this:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">boundary_grid_utm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subset</span><span class="p">(</span><span class="n">boundary_utm</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">"Trial"</span><span class="p">)</span><span class="w">
</span><span class="n">plot</span><span class="p">(</span><span class="n">boundary_grid_utm</span><span class="o">$</span><span class="n">geom</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../fig/rmd-unnamed-chunk-24-1.png" title="plot of chunk unnamed-chunk-24" alt="plot of chunk unnamed-chunk-24" width="612" style="display: block; margin: auto;" />
Now we will make subplots that are 24 meters wide:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_to_ft</span><span class="p">(</span><span class="m">24</span><span class="p">)</span><span class="w"> </span><span class="c1"># convert from meters to feet</span><span class="w">
</span></code></pre></div></div>

<p>Now we use <code class="highlighter-rouge">make_grids</code> to calculate subplots for our shapefile <font color="magenta">more words are needed here about these parameters</font></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">design_grids_utm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_grids</span><span class="p">(</span><span class="n">boundary_grid_utm</span><span class="p">,</span><span class="w">
                              </span><span class="n">abline_utm</span><span class="p">,</span><span class="w"> </span><span class="n">long_in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'NS'</span><span class="p">,</span><span class="w"> </span><span class="n">short_in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'EW'</span><span class="p">,</span><span class="w">
			      </span><span class="n">length_ft</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">width_ft</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>We need to make sure the coordinate system for both our grids and our original boundary file match up:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">st_crs</span><span class="p">(</span><span class="n">design_grids_utm</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st_crs</span><span class="p">(</span><span class="n">boundary_grid_utm</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Let‚Äôs plot what these grids will look like <font color="magenta"> we need to talk about what tm_shape is here or before</font></p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tm_shape</span><span class="p">(</span><span class="n">design_grids_utm</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tm_borders</span><span class="p">(</span><span class="n">col</span><span class="o">=</span><span class="s1">'blue'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../fig/rmd-plotting design grids now-1.png" title="plot of chunk plotting design grids now" alt="plot of chunk plotting design grids now" width="612" style="display: block; margin: auto;" /></p>

<p>Now the last step is that we want to make sure this grid overlaps <em>only</em> with our boundary file, so we take the intersection of this rectangular grid with our boundary file‚Äôs trial data outline:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">trial_grid_utm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st_intersection</span><span class="p">(</span><span class="n">boundary_grid_utm</span><span class="p">,</span><span class="w"> </span><span class="n">design_grids_utm</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="error highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Warning: attribute variables are assumed to be spatially constant throughout all
geometries
</code></pre></div></div>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tm_shape</span><span class="p">(</span><span class="n">trial_grid_utm</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tm_borders</span><span class="p">(</span><span class="n">col</span><span class="o">=</span><span class="s1">'blue'</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../fig/rmd-unnamed-chunk-28-1.png" title="plot of chunk unnamed-chunk-28" alt="plot of chunk unnamed-chunk-28" width="612" style="display: block; margin: auto;" /></p>
<font color="magenta"> there is an error here that we should fix or mention</font>

<h2 id="step-2-interpolationaggregation-on-our-subplots">Step 2: Interpolation/Aggregation on our subplots</h2>

<p>We will now aggregate our yield data over our subplots.</p>

<p>Interpolation is the estimation of a value at a point that we didn‚Äôt measure
that is between two or more points that we did measure.  Aggregation is the
combining of multiple data points into a single data point.  What we‚Äôll do here
is a combination of interpolation and aggregation, where we will use multiple
measurements across each subplot to generate one value for the subplot. In this
case we will take the median value within each subplot.  Typically when the data
are not normally-distributed or when there are errors, the median is more
representative of the data than the mean is.  Here we will interpolate and
aggregate yield as an example.  The other variables can be processed in the same
way.</p>

<p><strong>Question from Lindsay: Why do we need to covert class here?  Please provide an
explanation.</strong> <font color="magenta">not sure what "covert" means here, leaving this question for others</font></p>

<!-- JPN: no work

~~~
grid_sp = trial_grid_utm
merge <- sp::over(trial_grid_utm, yield_clean[,"Yld_Vol_Dr"], fn = median)
~~~
{: .language-r}



~~~
Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'over' for signature '"sf", "sf"'
~~~
{: .error}



~~~
grid_sp@data <- cbind(merge, grid_sp@data)
~~~
{: .language-r}



~~~
Error in cbind(merge, grid_sp@data): trying to get slot "data" from an object (class "sf") that is not an S4 object 
~~~
{: .error}



~~~
subplots_data <- st_as_sf(grid_sp) 
map_poly(subplots_data, 'Yld_Vol_Dr', "Yield (bu/ac)")
~~~
{: .language-r}



~~~
Error: Fill argument neither colors nor valid variable name(s)
~~~
{: .error}
-->

<p>One final step we have to do before aggregating is to explicitly tell R that our data is ‚ÄúSpatial‚Äù data.  This is a little quirk of R that we have to think about for both our trial grid and yield data:</p>

<font color="magenta">I would personally vote for function-izing the spatial conversion stuff since its new and also then we have to explain the [,] stuff since before we've only called columns with $</font>
<font color="green">Dena: ...if time permits! If not, explanations work</font>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">trial_grid_spatial</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as</span><span class="p">(</span><span class="n">trial_grid_utm</span><span class="p">,</span><span class="w"> </span><span class="s2">"Spatial"</span><span class="p">)</span><span class="w">
</span><span class="n">yield_clean_spatial</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">as</span><span class="p">(</span><span class="n">yield_clean</span><span class="p">[,</span><span class="s2">"Yld_Vol_Dr"</span><span class="p">],</span><span class="w"> </span><span class="s2">"Spatial"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>Let‚Äôs deposit on our grid using a function <code class="highlighter-rouge">deposit_on_grid</code> from <code class="highlighter-rouge">functions.R</code>:</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subplots_data</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">deposit_on_grid</span><span class="p">(</span><span class="n">trial_grid_spatial</span><span class="p">,</span><span class="w"> </span><span class="n">yield_clean_spatial</span><span class="p">,</span><span class="w"> </span><span class="n">fn</span><span class="o">=</span><span class="n">median</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>
<p>And let‚Äôs finally take a look!</p>

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map_poly</span><span class="p">(</span><span class="n">subplots_data</span><span class="p">,</span><span class="w"> </span><span class="s1">'Yld_Vol_Dr'</span><span class="p">,</span><span class="w"> </span><span class="s2">"Yield (bu/ac)"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p><img src="../fig/rmd-unnamed-chunk-32-1.png" title="plot of chunk unnamed-chunk-32" alt="plot of chunk unnamed-chunk-32" width="612" style="display: block; margin: auto;" /></p>

<!-- JPN: took out a lot


~~~
grid_sp <- as(trial_grid_utm, "Spatial")
crs(grid_sp)
~~~
{: .language-r}



~~~
CRS arguments:
 +proj=utm +zone=17 +datum=WGS84 +units=m +no_defs +ellps=WGS84
+towgs84=0,0,0 
~~~
{: .output}

**Explain more of what is happening in this code below**
**Why is one line commented out?**


~~~
merge <- sp::over(grid_sp, as(yield_clean[,"Yld_Vol_Dr"], "Spatial"), fn = median)
grid_sp@data <- cbind(merge, grid_sp@data)

subplots_data <- st_as_sf(grid_sp) 
map_poly(subplots_data, 'Yld_Vol_Dr', "Yield (bu/ac)")
~~~
{: .language-r}

<img src="../fig/rmd-aggregate yield data-1.png" title="plot of chunk aggregate yield data" alt="plot of chunk aggregate yield data" width="612" style="display: block; margin: auto;" />
-->
:ET