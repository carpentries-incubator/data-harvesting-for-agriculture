---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 01-R-RStudio.md in _episodes_rmd/
title: "Introduction to R and RStudio"
questions:
- "How can I work with a spreadsheet in a more advanced and reproducible manner than using MS Excel?"
- "How can I keep my data and analysis organized?"
- "How can I visualize my data with graphs?"
- "Why would basic programming skills be useful to me for these tasks?"
objectives:
- "Describe the purpose of each pane in the RStudio IDE"
- "Create a project to manage scripts and data"
- "Assign a value to a variable"
- "Perform arithmetic"
- "Use a function"
- "View the help page for a function"
- "Create a new function"
- "Import data from spreadsheet software"
- "Install packages"
- "Make a scatter plot using ggplot2"
source: Rmd
---



## Getting to know R and RStudio

In this episode we'll cover the basics of using R, which is a programming
language for statistics, data analysis, and data visualization.  In the past
decade or so, R has become very popular in both science and business, largely
because (1) it is free, and (2) thousands of people have written new code
extending its functionality, and that code is also free.  If you perform an
analysis in R, you can share that analysis so that anyone in the world can
reproduce it without having to purchase proprietary software.

If you're already proficient with Excel, you will probably already know how to
accomplish a lot of what we are doing in this episode using Excel instead of
R. One reason why we are teaching you this material, however, is to get you
comfortable with R since we will be using R for geospatial analysis (which is
not so easy in Excel).  The other reason is that with R, you can make your
analysis much more reproducible than you can with Excel or other graphical
software.  In R, everything you do goes into a plain text file called a *script*,
and to rerun your analysis you can simply rerun the same script.  Scripts are
also fairly easy to edit and repurpose (for example, redoing the exact same
analysis with next year's dataset) as well as share with other people (your
neighbor who wants to try your analysis but with his or her own data).

Separately from R, we asked you to install a piece of software called RStudio,
which will make R a lot easier to use.  Although there are paid, "enterprise"
versions of RStudio, the free version does everything that a typical user
needs.

Launch RStudio.  If this is the first time you have opened it, the entire left
pane will be taken up by something called the Console.  This has a prompt where
commands can be entered.


```r
5 + 7
```

```
## [1] 12
```

After you hit enter, you will see the result of the command.  But usually we
don't run commands from here, since we want to keep a record of everything we
did.  If you go to File &rarr; New File &rarr; R Script, the text editor will open in
the upper left, and you will be able to type commands there and save them in
a file.  To run a command from the script editor, put your cursor on the line
where the command starts and press the "Run" button.  Alternatively, you can
press Ctrl+Enter.

In addition to putting commands in your script, you can put *comments*.  A
comment is a line, or part of a line, that is ignored by R.  This means you can
use comments to explain what is happening in the code or why you did something
a certain way.  Comments start with the `#` character, and can take up the
whole line or just the end of a line.  As we go through this workshop, I
encourage you to put lots of comments in your code. Think of them as a way to
take notes!


```r
# Performing arithmetic
6 + 2
```

```
## [1] 8
```

```r
2 ^ 3 # this raises two to the third power
```

```
## [1] 8
```

We can save this script to a file on our computer, with the .R extension so that
RStudio knows to treat it like an R script (even though it is plain text).
We'll want to keep our scripts organized though, and probably store them with
the data that they will be processing.  Luckily RStudio has a feature called
"Projects" that makes it easy to stay organized.

Go to File &rarr; New Project.  Select "New Directory".  Here you will put the
name of a new folder and where you want it to be located on your computer.
For example, you can call the project "R_lesson".  Once the project is created,
you'll find that you can get to that same folder through Windows Explorer, or
on a Mac, Finder.  In RStudio, we see the contents of the folder in the "Files"
pane in the lower right.  Right now the only file there is called
`R_lesson.Rproj` (or whatever you called your project), which stores
settings for the project and can be ignored for now.  Use the "New Folder"
button to make a folder called "data", one called "scripts", and one called
"results".  We will put datasets into the data folder, keep all of our R scripts
in the scripts folder, and put any output files into the results folder.  While
it isn't strictly necessary to organize files in this way, it makes it a lot
easier to keep track of things.

Create a new script called `R_intro.R` and save it in your "scripts" folder.
We will work off of this file for the remainder of the episode, then start a
new script for the next episode.

## Dataset for this lesson

As an example of a dataset in spreadsheet form that we can use to demonstrate
the R language, we are using the USDA - Economic Research Service's fertilizer
use and price dataset, available at
https://www.ers.usda.gov/data-products/fertilizer-use-and-price.aspx.
Table 2 of this dataset, showing 1,000 nutrient short tons of nitrogen,
phosphorus, and potash used on corn, soy, cotton, wheat, and other crops in the
US from 1964-2016, has been reformatted into a CSV file for ease of import into
R.  You can download the CSV from
https://raw.githubusercontent.com/data-carpentry-for-agriculture/trial-lesson/gh-pages/_episodes_rmd/data/fertilizer_use.csv.
It can be opened in Excel if you want to get a quick look at it that way, or we can
dive straight into looking at it in R.  Save it into your `data` folder in
your RStudio project for this lesson.

In R, we can use a *function* called `read.csv` to import data from a CSV
(comma-separated value) file. When using any R function, we need opening and
closing parentheses after the function name.  Inside those parentheses we put
items called *arguments* that tell the function what to do.  In this case, we
will put the name of the file to read in quotes, including the folder that it is
in.  (You can use a forward slash regardless of whether you are on Windows or
another operating system.)  To the left of the function name we have the
*assignment operator*, `<-`, which we will use to put the data somewhere for
further processing.  In this case, we will make an *object* called `fert_use`
where we will store the data.


```r
fert_use <- read.csv("data/fertilizer_use.csv")
```

Now in the upper right pane of RStudio, we see `fert_use` listed within our
*environment*.

Immediately after loading a dataset, it is a good idea to inspect it and make
sure it looks like it is formatted correctly.  The `str` function is helpful
for getting a quick look.


```r
str(fert_use)
```

```
## 'data.frame':	265 obs. of  5 variables:
##  $ Year     : int  1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 ...
##  $ Crop     : Factor w/ 5 levels "Corn","Cotton",..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ Nitrogen : int  1623 2151 2596 3044 3116 3287 3520 3730 3705 3830 ...
##  $ Phosphate: int  1053 1336 1626 1857 1855 1789 2136 2024 1994 1988 ...
##  $ Potash   : int  829 1204 1513 1750 1778 1765 2046 1946 1992 2052 ...
```

We see that `fert_use` is something called a *data frame*, which is a typical
format in R for storing spreadsheet-like data.  There are five variables,
which we can see are Year, Crop, Nitrogen, Phosphate, and Potash.  Within each
variable there are 265 observations.  We also see that Year, Nitrogen, Phosphate,
and Potash are all represented as integers.  Crop is something called a factor,
which means it is text that is assumed to represent a set of categories.

**Note:**  If you are importing from `read.csv`, `read.table`, or a related
function and you want to treat text columns as text rather than categories,
set the argument `stringsAsFactors = FALSE`.  It is always easy to convert text
to a factor later, and many functions will do this on-the-fly for you.

### Exercise

In either Excel or RStudio's text editor, add a question mark after one of the
numbers in the file.  Re-run `read.csv` and `str`.  What is different?  How
might this be a problem?  Change the file back (or re-download it) when you are
done, then re-run the lines to load in the correct version of the dataset.

**Solution:** When `read.csv` encounters anything in a column that cannot be
formatted as a number, it treats the whole column as text, which by default
causes it to be imported as a factor.  If we want to perform math or make graphs
with numerical data, we won't be able to do so if it is formatted as a factor.

## Functions and vectors

We just used the `read.csv` and `str` functions.  Let's try out some math, now
that we have confirmed that everything that should be a number is a number.
We can use the `mean` function to find the average value of a variable.  How
can we extract one variable from a data frame?  The simplest way is to use
the `$` operator.  It will get us one column of the data frame, which in R
is something we call a *vector*.  `str` works on vectors as well to tell us
something about them.


```r
fert_use$Nitrogen
```

```
##   [1] 1623 2151 2596 3044 3116 3287 3520 3730 3705 3830 3773 3885 5210 5181 4888
##  [16] 5274 5244 5588 5360 3960 5391 5666 4807 4194 4499 4601 4748 4715 4887 4369
##  [31] 4603 4158 4829 4792 4846 4650 4909 4249 4720 4710 4792 5023 4690 5714 5224
##  [46] 4875 5610   NA   NA   NA 6317   NA 6123  394  453  330  269  319  405  323
##  [61]  343  404  337  421  240  353  416  351  352  371  387  330  218  343  325
##  [76]  309  324  390  347  419  477  466  508  649  700  563  525  472  544  567
##  [91]  569  508  508  502  517  559  441  421  345  380   NA   NA   NA   NA  268
## [106]   NA   16   19   40   56   67   48   63   62   72   95   87   74   70  113
## [121]  138  149  137  128  102  115  115   80   82   87  104   93  118  118   98
## [136]   84  100  154  116  175  141  139  160  148  155  154  156  151  109  121
## [151]  120  101  111  167  167   NA   NA  203   NA  353  427  424  624  624  569
## [166]  580  614  783  896 1078 1085 1456 1279 1047 1253 1570 1791 1781 1651 1866
## [181] 1746 1708 1633 1740 1924 1800 1734 1889 1986 2050 1955 2208 2043 2017 1907
## [196] 1891 1764 1751 1804 1957 1625 1430 1689 1647 1394 1331 1692 1584   NA   NA
## [211] 1715   NA 1967 1589 1935 2035 2663 2648 2974 3385 3057 3137 3798 3317 3322
## [226] 3658 3542 3686 4085 4030 3410 3183 3377 3675 3518 3971 3778 3628 3990 4243
## [241] 4106 4445 5240 4752 4588 4816 4837 5212 4808 4805 4875 4916 5621 5021 5256
## [256] 5229 5149 4746 4800   NA   NA   NA   NA   NA   NA
```

```r
str(fert_use$Nitrogen)
```

```
##  int [1:265] 1623 2151 2596 3044 3116 3287 3520 3730 3705 3830 ...
```

We can then pass the whole nitrogen vector to the `mean` function.


```r
mean(fert_use$Nitrogen)
```

```
## [1] NA
```

Whoops!  That is probably not what we wanted.  In R, `NA` means missing data.
You can see from when we printed out the whole vector that we have a lot of `NA`
values.  By default, if `mean` encounters any `NA` values, it returns `NA`.  To
figure out what to do, let's look at the help page.  To find the help page for any
function, type a question mark and then the name of the function.


```r
?mean
```

Ah, there is an argument called `na.rm`, and the description of it says that it
controls whether or not `NA` values are stripped out before calculating the mean.
We can also see that both `na.rm` and `trim` have default values.  We want to
leave `trim` at the default, so we will name `na.rm` when we use it, kind of like
it is named in the Usage section.  In R, `TRUE` and `FALSE` should always be in
all caps.


```r
mean(fert_use$Nitrogen, na.rm = TRUE)
```

```
## [1] 2070.918
```

Note that `fert_use$Nitrogen` got passed to the `x` argument.  If we use
arguments in the exact order they appear in the help file, we don't have to name
them.  But honestly, sometimes naming our arguments just makes code more readable.
And readability is good if you plan on looking at your code again next year
and remembering what you did and why.


```r
mean(x = fert_use$Nitrogen, na.rm = TRUE)
```

```
## [1] 2070.918
```

If we look up `?median`, we can see that there is a similar function for getting
the median of a set of values.  Sometimes the median is a lot more useful than
the mean if there are extreme values in the data set.


```r
median(fert_use$Nitrogen, na.rm = TRUE)
```

```
## [1] 1629
```

### Exercise

Is there a function to get the maximum value of a vector?  Try to find the
help page for it, or use Google to find the function name if that fails you.
What are the arguments?  Try finding the maximum amount of phosphate applied
to any crop across all years.

**Solution:** The function is called `max`, and we can view the help page by
typing `?max`.  Like `mean` and `median`, there is an `na.rm` argument to
ignore missing data.  We also see an argument `...`.  Because this is the
first argument, it means you can put in multiple vectors and get the maximum
value across all of them.  We can get the maximum phosphate this way:


```r
max(fert_use$Phosphate, na.rm = TRUE)
```

```
## [1] 2550
```

### Looking at distributions of all numerical columns at once

The `summary` function gives us values like the minimum, maximum, mean, and
median for every column in the data frame at once, and, along with `str`,
can be a good way to get an overview of our data immediately after we import
it.


```r
summary(fert_use)
```

```
##       Year            Crop       Nitrogen        Phosphate     
##  Min.   :1964   Corn    :53   Min.   :  16.0   Min.   :  57.0  
##  1st Qu.:1977   Cotton  :53   1st Qu.: 335.2   1st Qu.: 299.8  
##  Median :1990   Other   :53   Median :1629.0   Median : 635.5  
##  Mean   :1990   Soybeans:53   Mean   :2070.9   Mean   : 904.4  
##  3rd Qu.:2003   Wheat   :53   3rd Qu.:3903.8   3rd Qu.:1606.0  
##  Max.   :2016                 Max.   :6317.0   Max.   :2550.0  
##                               NA's   :21       NA's   :21      
##      Potash      
##  Min.   :  62.0  
##  1st Qu.: 215.8  
##  Median : 690.5  
##  Mean   : 971.1  
##  3rd Qu.:1769.0  
##  Max.   :3038.0  
##  NA's   :21
```

Why bother using `mean`, `median`, and `max` then?  As we'll see below, because
those functions give us single numbers, we can use those numbers to do further
arithmetic.

## Arithmetic

A handy feature of R is vectorized arithmetic, meaning we can do arithmetic on
a whole vector at once.  For example, to convert the units for nitrogen application
from thousands of short tons to short tons, we could multiply by 1000.


```r
fert_use$Nitrogen * 1000
```

```
##   [1] 1623000 2151000 2596000 3044000 3116000 3287000 3520000 3730000 3705000
##  [10] 3830000 3773000 3885000 5210000 5181000 4888000 5274000 5244000 5588000
##  [19] 5360000 3960000 5391000 5666000 4807000 4194000 4499000 4601000 4748000
##  [28] 4715000 4887000 4369000 4603000 4158000 4829000 4792000 4846000 4650000
##  [37] 4909000 4249000 4720000 4710000 4792000 5023000 4690000 5714000 5224000
##  [46] 4875000 5610000      NA      NA      NA 6317000      NA 6123000  394000
##  [55]  453000  330000  269000  319000  405000  323000  343000  404000  337000
##  [64]  421000  240000  353000  416000  351000  352000  371000  387000  330000
##  [73]  218000  343000  325000  309000  324000  390000  347000  419000  477000
##  [82]  466000  508000  649000  700000  563000  525000  472000  544000  567000
##  [91]  569000  508000  508000  502000  517000  559000  441000  421000  345000
## [100]  380000      NA      NA      NA      NA  268000      NA   16000   19000
## [109]   40000   56000   67000   48000   63000   62000   72000   95000   87000
## [118]   74000   70000  113000  138000  149000  137000  128000  102000  115000
## [127]  115000   80000   82000   87000  104000   93000  118000  118000   98000
## [136]   84000  100000  154000  116000  175000  141000  139000  160000  148000
## [145]  155000  154000  156000  151000  109000  121000  120000  101000  111000
## [154]  167000  167000      NA      NA  203000      NA  353000  427000  424000
## [163]  624000  624000  569000  580000  614000  783000  896000 1078000 1085000
## [172] 1456000 1279000 1047000 1253000 1570000 1791000 1781000 1651000 1866000
## [181] 1746000 1708000 1633000 1740000 1924000 1800000 1734000 1889000 1986000
## [190] 2050000 1955000 2208000 2043000 2017000 1907000 1891000 1764000 1751000
## [199] 1804000 1957000 1625000 1430000 1689000 1647000 1394000 1331000 1692000
## [208] 1584000      NA      NA 1715000      NA 1967000 1589000 1935000 2035000
## [217] 2663000 2648000 2974000 3385000 3057000 3137000 3798000 3317000 3322000
## [226] 3658000 3542000 3686000 4085000 4030000 3410000 3183000 3377000 3675000
## [235] 3518000 3971000 3778000 3628000 3990000 4243000 4106000 4445000 5240000
## [244] 4752000 4588000 4816000 4837000 5212000 4808000 4805000 4875000 4916000
## [253] 5621000 5021000 5256000 5229000 5149000 4746000 4800000      NA      NA
## [262]      NA      NA      NA      NA
```

Works great, and the `NA`s even carried over.

But wait...


```r
fert_use$Nitrogen
```

```
##   [1] 1623 2151 2596 3044 3116 3287 3520 3730 3705 3830 3773 3885 5210 5181 4888
##  [16] 5274 5244 5588 5360 3960 5391 5666 4807 4194 4499 4601 4748 4715 4887 4369
##  [31] 4603 4158 4829 4792 4846 4650 4909 4249 4720 4710 4792 5023 4690 5714 5224
##  [46] 4875 5610   NA   NA   NA 6317   NA 6123  394  453  330  269  319  405  323
##  [61]  343  404  337  421  240  353  416  351  352  371  387  330  218  343  325
##  [76]  309  324  390  347  419  477  466  508  649  700  563  525  472  544  567
##  [91]  569  508  508  502  517  559  441  421  345  380   NA   NA   NA   NA  268
## [106]   NA   16   19   40   56   67   48   63   62   72   95   87   74   70  113
## [121]  138  149  137  128  102  115  115   80   82   87  104   93  118  118   98
## [136]   84  100  154  116  175  141  139  160  148  155  154  156  151  109  121
## [151]  120  101  111  167  167   NA   NA  203   NA  353  427  424  624  624  569
## [166]  580  614  783  896 1078 1085 1456 1279 1047 1253 1570 1791 1781 1651 1866
## [181] 1746 1708 1633 1740 1924 1800 1734 1889 1986 2050 1955 2208 2043 2017 1907
## [196] 1891 1764 1751 1804 1957 1625 1430 1689 1647 1394 1331 1692 1584   NA   NA
## [211] 1715   NA 1967 1589 1935 2035 2663 2648 2974 3385 3057 3137 3798 3317 3322
## [226] 3658 3542 3686 4085 4030 3410 3183 3377 3675 3518 3971 3778 3628 3990 4243
## [241] 4106 4445 5240 4752 4588 4816 4837 5212 4808 4805 4875 4916 5621 5021 5256
## [256] 5229 5149 4746 4800   NA   NA   NA   NA   NA   NA
```

That didn't save our work.  Any time we want to change the value of something in R,
we have to use the `<-` operator.  We probably want to avoid overwriting our
nitrogen column anyway; let's make a new column with a new name.


```r
fert_use$Nitrogen_short_tons <- fert_use$Nitrogen * 1000
str(fert_use)
```

```
## 'data.frame':	265 obs. of  6 variables:
##  $ Year               : int  1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 ...
##  $ Crop               : Factor w/ 5 levels "Corn","Cotton",..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ Nitrogen           : int  1623 2151 2596 3044 3116 3287 3520 3730 3705 3830 ...
##  $ Phosphate          : int  1053 1336 1626 1857 1855 1789 2136 2024 1994 1988 ...
##  $ Potash             : int  829 1204 1513 1750 1778 1765 2046 1946 1992 2052 ...
##  $ Nitrogen_short_tons: num  1623000 2151000 2596000 3044000 3116000 ...
```

Ok, that worked!  The new column is "numeric" instead of "integer", but unless
we're getting really advanced with R, we don't care about the difference between
those.

We can also do arithmetic with multiple vectors.


```r
fert_use$All_inputs <- fert_use$Nitrogen + fert_use$Phosphate + fert_use$Potash
head(fert_use)
```

```
##   Year Crop Nitrogen Phosphate Potash Nitrogen_short_tons All_inputs
## 1 1964 Corn     1623      1053    829             1623000       3505
## 2 1965 Corn     2151      1336   1204             2151000       4691
## 3 1966 Corn     2596      1626   1513             2596000       5735
## 4 1967 Corn     3044      1857   1750             3044000       6651
## 5 1968 Corn     3116      1855   1778             3116000       6749
## 6 1969 Corn     3287      1789   1765             3287000       6841
```

### Challenge

Make a new column called `NP` that is the sum of nitrogen and phosphate applied.
Then make another column called `NP_centered`, which is the value of `NP` minus
the mean of `NP`.  This new column will have negative values if the total amount
of nitrogen and phosphorus applied was less than average, and positive if it was
more than average.  Centering like this can be useful in various statistical
analyses.

**Solution:**


```r
fert_use$NP <- fert_use$Nitrogen + fert_use$Phosphate
fert_use$NP_centered <- fert_use$NP - mean(fert_use$NP, na.rm = TRUE)
head(fert_use)
```

```
##   Year Crop Nitrogen Phosphate Potash Nitrogen_short_tons All_inputs   NP
## 1 1964 Corn     1623      1053    829             1623000       3505 2676
## 2 1965 Corn     2151      1336   1204             2151000       4691 3487
## 3 1966 Corn     2596      1626   1513             2596000       5735 4222
## 4 1967 Corn     3044      1857   1750             3044000       6651 4901
## 5 1968 Corn     3116      1855   1778             3116000       6749 4971
## 6 1969 Corn     3287      1789   1765             3287000       6841 5076
##   NP_centered
## 1   -299.3156
## 2    511.6844
## 3   1246.6844
## 4   1925.6844
## 5   1995.6844
## 6   2100.6844
```

## Creating your own functions

Let's say we want to convert short tons to metric tons so that we can compare
these numbers to some reported from Europe.  Similarly to above, we can do


```r
fert_use$Nitrogen_metric_tons <- fert_use$Nitrogen_short_tons * 0.907
```

We can make similar lines for phosphate and potash.  There's nothing
particularly wrong with this, but we can make the code a bit easier to read and
edit by defining a new function for the conversion.


```r
ShortTonsToMetricTons <- function(val){
  out <- val * 0.907
  return(out)
}

ShortTonsToMetricTons(5)
```

```
## [1] 4.535
```

```r
fert_use$Nitrogen_metric_tons <- 
  ShortTonsToMetricTons(fert_use$Nitrogen_short_tons)
```

What did I just do there?  I used the `function` keyword to create a new
function, and I used the assignment operator (`<-`) to give that function a
name.  The object `val` is an *argument* for the function, and you'll notice that
neither `val` nor `out` appear in your global environment after running the
function.  Between the curly brackets (`{}`), is what we call the
*function body*, which describes what computations the function should perform.
There is also a `return` statement that shows what the function *returns*,
*i.e.* what the output should be.

Now, when reading back through your code, you don't have to remember what the
number 0.907 was for; you have a function name that describes what it does.
Additionally, say you later decide that you want to make the conversion with
more precision.


```r
ShortTonsToMetricTons <- function(val){
  out <- val * 0.907185
  return(out)
}
```

There's only one place that you have to edit the number, even if you use the
function dozens of times in your code.  That's a lot less error-prone than
going back and editing the number in dozens of places.  You still have to
re-run the code to change all of the results, but at least the editing is
minimal.

That was a relatively simple example, but later when you write much larger
chunks of code and want to avoid having to copy and paste it all, functions
can be very helpful.  We'll make a few functions in later episodes of this
lesson, which is why we introduced the concept here.

## Installing packages

There are over 15,000 add-on packages for R, all completely free.
CRAN is the official place where they are hosted, and you can see a list of
CRAN packages here:
https://cloud.r-project.org/web/packages/available_packages_by_name.html

Additionally, many people who create small R packages and don't want to deal
with the hassle of hosting them on CRAN will make their package available
via GitHub.  If you really get into R and want to share your code with others,
you might even make your own R package one day!

In the meantime, let's see how to get R packages from CRAN.  For this episode,
we will use a package called `ggplot2`.  The function for installing packages
is called `install.packages()`.


```r
install.packages("ggplot2")
```

Once a package has been installed, we don't need to install it again until we
upgrade R.  To avoid accidentally reinstalling, this is a good time to
"comment out" our code.


```r
#install.packages("ggplot2")
```

If we want to use a particular package in our script, we also need to load it
with `library()`.  We won't comment that out, since we will need to do it
every time we reopen R and run the script.  Generally, it is good to put
all calls to `library()` at the top of the script, so that as soon as you
(or someone else) open the script, you know what you need to have installed.


```r
library(ggplot2)
```

(It's one of R's little quirks that package names need to be in quotes for
installation, but not for loading.)

### Exercise

Later today we will use the package `rgdal`.  Install it and load it.

**Solution:**


```r
install.packages("rgdal")
library(rgdal)
```

## Graphics with ggplot2

Although there are other packages for making graphics, `ggplot2` is popular
for being easy to learn and versatile.  We'll scratch the surface of it in this
lesson.  To learn more, go to https://ggplot2.tidyverse.org/.

Let's plot nitrogen applied vs. year.  To start, we will pass our data frame
to the `ggplot` function as the first argument.  The second argument is a set
of *aesthetics* indicating how variables should correspond to various aspects
of the plot.


```r
ggplot(fert_use, aes(x = Year, y = Nitrogen))
```

![plot of chunk unnamed-chunk-25](figure/unnamed-chunk-25-1.png)

This sets up the plot but doesn't put anything in it.  We can use `geom_point` to
make a scatter plot.  We will use the `+` operator to connect these commands.


```r
ggplot(fert_use, aes(x = Year, y = Nitrogen)) +
  geom_point()
```

```
## Warning: Removed 21 rows containing missing values (geom_point).
```

![plot of chunk unnamed-chunk-26](figure/unnamed-chunk-26-1.png)

Looks like some crops changed over time and others didn't.  But which ones?


```r
ggplot(fert_use, aes(x = Year, y = Nitrogen, color = Crop)) +
  geom_point()
```

```
## Warning: Removed 21 rows containing missing values (geom_point).
```

![plot of chunk unnamed-chunk-27](figure/unnamed-chunk-27-1.png)

Maybe we want to add some lines connecting the years.  In the help page for
`geom_line`, we see the `group` aesthetic, which we will also need here.


```r
ggplot(fert_use, aes(x = Year, y = Nitrogen, color = Crop, group = Crop)) +
  geom_point() +
  geom_line()
```

```
## Warning: Removed 21 rows containing missing values (geom_point).
```

```
## Warning: Removed 9 rows containing missing values (geom_path).
```

![plot of chunk unnamed-chunk-28](figure/unnamed-chunk-28-1.png)

We can also make separate plots for each crop using the `facet_wrap` function.
Since some crops used a lot less nitrogen than others, we'll set
`scales = "free_y"` to get a better picture of how each crop changed over time.
Notice also that we need the `~` symbol with `facet_wrap`.


```r
ggplot(fert_use, aes(x = Year, y = Nitrogen, color = Crop, group = Crop)) +
  geom_point() +
  geom_line() +
  facet_wrap(~ Crop, scales = "free_y")
```

```
## Warning: Removed 21 rows containing missing values (geom_point).
```

```
## Warning: Removed 9 rows containing missing values (geom_path).
```

![plot of chunk unnamed-chunk-29](figure/unnamed-chunk-29-1.png)

### Exercise

Make a scatter plot of nitrogen vs. potash, and color it by crop.  Make
another plot where instead of coloring by crop, you facet by crop.
Now try it with `facet_wrap(~ Year > 1980)`.  What happens?

**Solution:**

```r
ggplot(fert_use, aes(x = Potash, y = Nitrogen, color = Crop)) +
  geom_point()
```

![plot of chunk unnamed-chunk-30](figure/unnamed-chunk-30-1.png)

```r
ggplot(fert_use, aes(x = Potash, y = Nitrogen)) +
  geom_point() +
  facet_wrap(~ Crop)
```

![plot of chunk unnamed-chunk-30](figure/unnamed-chunk-30-2.png)

```r
ggplot(fert_use, aes(x = Potash, y = Nitrogen, color = Crop)) +
  geom_point() +
  facet_wrap(~ Year > 1980)
```

![plot of chunk unnamed-chunk-30](figure/unnamed-chunk-30-3.png)

## Quick intro to `dplyr`

Since we'll use it a little bit in later episodes, we will introduce the
`dplyr` package.  It has some tools to make code a little more intuitive and
readable, especially when working with data frames.


```r
install.packages("dplyr") # install it if you haven't already
```

```r
library(dplyr)
```

```
## 
## Attaching package: 'dplyr'
```

```
## The following objects are masked from 'package:stats':
## 
##     filter, lag
```

```
## The following objects are masked from 'package:base':
## 
##     intersect, setdiff, setequal, union
```

One handy thing in `dplyr` is the *pipe symbol*, `%>%`.  Whatever is to the
left of the symbol gets sent to the first argument of the function to the right
of the symbol.  Consider:


```r
mean(ShortTonsToMetricTons(fert_use$Potash * 1000), na.rm = TRUE)
```

```
## [1] 880928.7
```

versus:


```r
(fert_use$Potash * 1000) %>%
  ShortTonsToMetricTons() %>%
  mean(na.rm = TRUE)
```

```
## [1] 880928.7
```

Both are just one command, but in the second version it is a bit easier to see
the series of computations being performed.

There are many handy functions in `dplyr`, and you can learn more at
https://dplyr.tidyverse.org/.  One more that we'll cover here is `filter`.


```r
filter(fert_use, Year > 2013, Crop != "Other")
```

```
##    Year     Crop Nitrogen Phosphate Potash Nitrogen_short_tons All_inputs   NP
## 1  2014     Corn     6317      2288   2408             6317000      11013 8605
## 2  2015     Corn       NA        NA     NA                  NA         NA   NA
## 3  2016     Corn     6123      2081   2249             6123000      10453 8204
## 4  2014   Cotton       NA        NA     NA                  NA         NA   NA
## 5  2015   Cotton      268       100    133              268000        501  368
## 6  2016   Cotton       NA        NA     NA                  NA         NA   NA
## 7  2014 Soybeans       NA        NA     NA                  NA         NA   NA
## 8  2015 Soybeans      203       831   1332              203000       2366 1034
## 9  2016 Soybeans       NA        NA     NA                  NA         NA   NA
## 10 2014    Wheat       NA        NA     NA                  NA         NA   NA
## 11 2015    Wheat     1715       613    185             1715000       2513 2328
## 12 2016    Wheat       NA        NA     NA                  NA         NA   NA
##    NP_centered Nitrogen_metric_tons
## 1    5629.6844              5729519
## 2           NA                   NA
## 3    5228.6844              5553561
## 4           NA                   NA
## 5   -2607.3156               243076
## 6           NA                   NA
## 7           NA                   NA
## 8   -1941.3156               184121
## 9           NA                   NA
## 10          NA                   NA
## 11   -647.3156              1555505
## 12          NA                   NA
```

(Here, `>` means "greater than" and `!=` means "not equal to".  If we wanted
"equal to", we would use `==`.)

This function returns a new data frame that just has the rows we specify.  It
can be handy for subsetting the data before plotting with ggplot.


```r
fert_use %>%
  filter(Year > 1980) %>%
  ggplot(aes(x = Year, y = Nitrogen, color = Crop, group = Crop)) +
  geom_point() +
  geom_line() +
  facet_wrap(~ Crop, scales = "free_y")
```

```
## Warning: Removed 21 rows containing missing values (geom_point).
```

```
## Warning: Removed 9 rows containing missing values (geom_path).
```

![plot of chunk unnamed-chunk-36](figure/unnamed-chunk-36-1.png)

